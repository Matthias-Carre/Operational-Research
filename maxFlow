import parser

def adjacentList(edgeList,nnode): #revoie un dico avec les voisins de chaque sommet composer de (nom, flow, cost)
    aL={}
    for i in range(nnode):
        aL[i] = []
    for egde in edgeList:
        if egde[0] not in aL:
            aL[egde[0]] = [egde[1:]]
        else:
            aL[egde[0]].append(egde[1:])

    print("Liste d'adja:", aL)
    return aL



#dfs qui revoie le chemin de la source a la cible
def dfs(adjList, source, target, visited):
    current = source
    visited.append(current)
    if current == target:
        return visited
    ToDo = adjList[current][0]
    while ToDo:
        nextNode = ToDo.pop(0)
        print("nei",nextNode)
        for neighbor in adjList[nextNode]:
            if neighbor[0] not in visited:
                ToDo.append(neighbor[0])
                if neighbor[0] == target:
                    return visited
    return False

def dfs(adjList, source, target, visited=None, path=None):
    if visited is None:
        visited = set()
    if path is None:
        path = []
    visited.add(source)
    path.append(source)

    # on arrive sur le sink
    if source == target:
        return path

    #pour tout les voisin actuel on check autour et on jump dessus si besoin
    for neighbor in adjList[source]:
        nextNode = neighbor[0]
        if nextNode not in visited:
            result = dfs(adjList, nextNode, target, visited, path)
            if result:  # Si un chemin est trouvé, on le retourne
                return result

    #le chemin actuel n'arrive pas sur le sink (on remonte dans le dfs)
    path.pop()
    return ""

#renvoie les infos de node1 vers node2
def getEdge(adjList, node1, node2):
    for neighbor in adjList[node1]:
        if neighbor[0] == node2:
            return neighbor
    return False

#modifie le chemin etre node1 et node2 avec newflow
def reduceFlowEgde(adjList, node1, node2, newFlow):
    for neighbor in adjList[node1]:
        if neighbor[0] == node2:
            neighbor[1] -= newFlow 
            if neighbor[1] == 0:
                adjList[node1].remove(neighbor)
            return


def increaseFlowEgde(adjList, node1, node2, newFlow):
    for neighbor in adjList[node1]:
        if neighbor[0] == node2:
            neighbor[1] += newFlow
            return
    adjList[node1].append([node2, newFlow,0])

#prend un chemin et une liste daj et revoie le residuel
def residuel(chemin, adjList):
    #on veux le plus petit flow
    
    
    minFlow = getEdge(adjList, chemin[0], chemin[1])[1]
    previus = chemin[0]
    for node in chemin[1:]:
        flow = getEdge(adjList, previus, node)[1]
        if flow < minFlow:
            minFlow = flow
        previus = node
    #print("minFlow", minFlow)

    #on reduit le flow du chemin:
    for node in chemin:
        if node == chemin[0]:
            previus = node
            continue
        reduceFlowEgde(adjList, previus, node, minFlow)
        increaseFlowEgde(adjList, node, previus, minFlow)
        previus = node
    print("adjList", adjList)





def main():
    data = parser.main()
    print("data",data)
    adjList = adjacentList(data[1], data[0]["numNodes"])
    print("Liste d'adja:", adjList)

    path = dfs(adjList, data[0]["Source"], data[0]["Sink"])
    while path != "":
        print("Chemin trouvé :", path)
        residuel(path, adjList)
        path = dfs(adjList, data[0]["Source"], data[0]["Sink"])
    
    print("max flow:", adjList)


if __name__ == "__main__":
    main()